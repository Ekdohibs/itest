
cablenodes={}

cablepos={}

function cable_addbox(t, b)
	for i in ipairs(b)
		do table.insert(t, b[i])
	end
end

function in_table(table,element)
	for _,el in ipairs(table) do
		if el==element then return true end
	end
	return false
end

function is_cable(nodename)
	return in_table(cablenodes,nodename)
end

function is_energy(nodename)
	--print(nodename)
	--print(tostring(minetest.get_item_group(nodename, "energy_conductor")+minetest.get_item_group(nodename, "energy_producer")+minetest.get_item_group(nodename, "energy_consumer")))
	return (minetest.get_item_group(nodename, "energy_conductor")+minetest.get_item_group(nodename, "energy_producer")+minetest.get_item_group(nodename, "energy_consumer")+minetest.get_item_group(nodename, "energy"))>0
end

function cable_scanforobjects(pos)
	cable_autoroute({ x=pos.x-1, y=pos.y  , z=pos.z   })
	cable_autoroute({ x=pos.x+1, y=pos.y  , z=pos.z   })
	cable_autoroute({ x=pos.x  , y=pos.y-1, z=pos.z   })
	cable_autoroute({ x=pos.x  , y=pos.y+1, z=pos.z   })
	cable_autoroute({ x=pos.x  , y=pos.y  , z=pos.z-1 })
	cable_autoroute({ x=pos.x  , y=pos.y  , z=pos.z+1 })
	cable_autoroute(pos)
end

function cable_autoroute(pos)
	nctr = minetest.env:get_node(pos)
	if not is_cable(nctr.name) then return end

	pxm=0
	pxp=0
	pym=0
	pyp=0
	pzm=0
	pzp=0

	nxm = minetest.env:get_node({ x=pos.x-1, y=pos.y  , z=pos.z   })
	nxp = minetest.env:get_node({ x=pos.x+1, y=pos.y  , z=pos.z   })
	nym = minetest.env:get_node({ x=pos.x  , y=pos.y-1, z=pos.z   })
	nyp = minetest.env:get_node({ x=pos.x  , y=pos.y+1, z=pos.z   })
	nzm = minetest.env:get_node({ x=pos.x  , y=pos.y  , z=pos.z-1 })
	nzp = minetest.env:get_node({ x=pos.x  , y=pos.y  , z=pos.z+1 })

	if is_energy(nxm.name) then pxm=1 end
	if is_energy(nxp.name) then pxp=1 end
	if is_energy(nym.name) then pym=1 end
	if is_energy(nyp.name) then pyp=1 end
	if is_energy(nzm.name) then pzm=1 end
	if is_energy(nzp.name) then pzp=1 end

	nsurround = pxm..pxp..pym..pyp..pzm..pzp
	if is_energy(nctr.name) then
		local meta=minetest.env:get_meta(pos)
		local meta0=meta:to_table()
		nctr.name=string.sub(nctr.name,1,-7)..nsurround
		minetest.env:add_node(pos, nctr)
		local meta=minetest.env:get_meta(pos)
		meta:from_table(meta0)
	end

end

tube_leftstub = {
	{ -32/64, -9/64, -9/64, 9/64, 9/64, 9/64 },	-- tube segment against -X face
}

tube_rightstub = {
	{ -9/64, -9/64, -9/64,  32/64, 9/64, 9/64 },	-- tube segment against +X face
}

tube_bottomstub = {
	{ -9/64, -32/64, -9/64,   9/64, 9/64, 9/64 },	-- tube segment against -Y face
}


tube_topstub = {
	{ -9/64, -9/64, -9/64,   9/64, 32/64, 9/64 },	-- tube segment against +Y face
}

tube_frontstub = {
	{ -9/64, -9/64, -32/64,   9/64, 9/64, 9/64 },	-- tube segment against -Z face
}

tube_backstub = {
	{ -9/64, -9/64, -9/64,   9/64, 9/64, 32/64 },	-- tube segment against -Z face
} 

tube_selectboxes = {
	{ -32/64,  -10/64,  -10/64,  10/64,  10/64,  10/64 },
	{ -10/64 ,  -10/64,  -10/64, 32/64,  10/64,  10/64 },
	{ -10/64 , -32/64,  -10/64,  10/64,  10/64,  10/64 },
	{ -10/64 ,  -10/64,  -10/64,  10/64, 32/64,  10/64 },
	{ -10/64 ,  -10/64, -32/64,  10/64,  10/64,  10/64 },
	{ -10/64 ,  -10/64,  -10/64,  10/64,  10/64, 32/64 }
}

function add_cbl(pos)
	cablepos[minetest.hash_node_postion(pos)]=pos
end

function rm_cbl(pos)
	cablepos[minetest.hash_node_postion(pos)]=nil
end
function register_cable(name,desc,texture,inv_texture,special)
for xm = 0, 1 do
for xp = 0, 1 do
for ym = 0, 1 do
for yp = 0, 1 do
for zm = 0, 1 do
for zp = 0, 1 do
	local outboxes = {}
	local outsel = {}
	local outimgs = {}

	if yp==1 then
		cable_addbox(outboxes, tube_topstub)
		table.insert(outsel, tube_selectboxes[4])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end
	if ym==1 then
		cable_addbox(outboxes, tube_bottomstub)
		table.insert(outsel, tube_selectboxes[3])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end
	if xp==1 then
		cable_addbox(outboxes, tube_rightstub)
		table.insert(outsel, tube_selectboxes[2])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end
	if xm==1 then
		cable_addbox(outboxes, tube_leftstub)
		table.insert(outsel, tube_selectboxes[1])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end
	if zp==1 then
		cable_addbox(outboxes, tube_backstub)
		table.insert(outsel, tube_selectboxes[6])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end
	if zm==1 then
		cable_addbox(outboxes, tube_frontstub)
		table.insert(outsel, tube_selectboxes[5])
		table.insert(outimgs, texture)
	else
		table.insert(outimgs, texture)
	end

	local jx = xp+xm
	local jy = yp+ym
	local jz = zp+zm

	local tname = xm..xp..ym..yp..zm..zp
	local tgroups = ""

	if tname ~= "000000" then
		tgroups = {snappy=3, energy_conductor=1, not_in_creative_inventory=1}
		tubedesc = desc.." ("..tname..")... You hacker, you."
		iimg=nil
		wscale = {x=1,y=1,z=1}
	else
		tgroups = {snappy=3, energy_conductor=1}
		tubedesc = desc
		iimg=inv_texture
		outimgs = {
			texture,texture,
			texture,texture,
			texture,texture
		}
		outboxes = { -24/64, -9/64, -9/64, 24/64, 9/64, 9/64 }
		outsel = { -24/64, -10/64, -10/64, 24/64, 10/64, 10/64 }
		wscale = {x=1,y=1,z=0.01}
	end
	
	table.insert(cablenodes,name.."_"..tname)
	
	nodedef={
		description = tubedesc,
		drawtype = "nodebox",
		tiles = outimgs,
		inventory_image=iimg,
		wield_image=iimg,
		wield_scale=wscale,
		paramtype = "light",
		selection_box = {
	             	type = "fixed",
			fixed = outsel
		},
		node_box = {
			type = "fixed",
			fixed = outboxes
		},
		groups = tgroups,
		sounds = default.node_sound_wood_defaults(),
		walkable = true,
		stack_max = 99,
		drop = name.."_000000",
		on_construct = function(pos)
			add_cbl(pos)
			if minetest.registered_nodes[name.."_"..tname].on_construct_ then
				minetest.registered_nodes[name.."_"..tname].on_construct_(pos)
			end
		end,
		after_place_node = function(pos)
			cable_scanforobjects(pos)
			if minetest.registered_nodes[name.."_"..tname].after_place_node_ then
				minetest.registered_nodes[name.."_"..tname].after_place_node_(pos)
			end
		end,
		after_dig_node = function(pos)
			cable_scanforobjects(pos)
			if minetest.registered_nodes[name.."_"..tname].after_dig_node_ then
				minetest.registered_nodes[name.."_"..tname].after_dig_node_(pos)
			end
		end,
		on_destruct = function(pos)
			rm_cbl(pos)
			if minetest.registered_nodes[name.."_"..tname].on_destruct_ then
				minetest.registered_nodes[name.."_"..tname].on_destruct_(pos)
			end
		end
	}
	
	if special==nil then special={} end

	for key,value in pairs(special) do
		if key=="on_construct" or key=="after_dig_node" or key=="after_place_node" or key=="on_destruct" then
			nodedef[key.."_"]=value
		elseif key=="groups" then
			for group,val in pairs(value) do
				nodedef.groups[group]=val
			end
		else
			nodedef[key]=value
		end
	end
	
	minetest.register_node(name.."_"..tname, nodedef)

end
end
end
end
end
end
end


minetest.register_node("energy:battery",{
	description = "Battery",
	drawtype="normal",
	tiles={"pipeworks_autocrafter.png"},
	groups={snappy=3,energy=1},
	on_construct = function(pos)
		local meta = minetest.env:get_meta(pos)
		meta:set_int("energy",0)
		meta:set_string("infotext", "Battery:0")
	end})

--minetest.register_node("energy:cable",{
--	description = "Cable",
--	drawtype="normal",
--	tiles={"pipeworks_autocrafter.png"},
--	groups={snappy=3,energy_conductor=1}})

register_cable("energy:cable","Cable","pipeworks_autocrafter.png","pipeworks_autocrafter.png")

minetest.register_node("energy:producer",{
	description = "Producer",
	drawtype="normal",
	tiles={"pipeworks_autocrafter.png"},
	groups={snappy=3,energy_producer=1},
	on_construct = function(pos)
		local meta = minetest.env:get_meta(pos)
		meta:set_int("energy_production",1)
	end})

minetest.register_node("energy:consumer",{
	description = "Consumer",
	drawtype="normal",
	tiles={"pipeworks_autocrafter.png"},
	groups={snappy=3,energy_consumer=1},
	on_construct = function(pos)
		local meta = minetest.env:get_meta(pos)
		meta:set_int("energy_use",1)
		meta:set_int("active",0)
	end})

function energy_find_nodes(pos)
	conductors={}
	producers={}
	consumers={}
	if energy_find(pos,conductors,producers,consumers,pos) then return {conductors={},producers={},consumers={}} end
	return {conductors=conductors,producers=producers,consumers=consumers}
end

adj={{x=0,y=0,z=1},{x=0,y=0,z=-1},{x=0,y=1,z=0},{x=0,y=-1,z=0},{x=1,y=0,z=0},{x=-1,y=0,z=0}}

function addVect(pos,vect)
return {x=pos.x+vect.x,y=pos.y+vect.y,z=pos.z+vect.z}
end

function posinlist(pos,list)
	for _,val in ipairs(list) do
		if pos.x==val.x and pos.y==val.y and pos.z==val.z then return true end
	end
end

function energy_find(pos,conductors,producers,consumers,start_pos)
	for _,vect in ipairs(adj) do
		local pos1=addVect(pos,vect)
		local node=minetest.env:get_node(pos1)
		if not(posinlist(pos1,conductors) or posinlist(pos1,producers) or posinlist(pos1,consumers)) then
			if minetest.get_item_group(node.name,"energy_conductor")==1 then
				conductors[#(conductors)+1]=pos1
				if energy_find(pos1,conductors,producers,consumers,start_pos) then return true end
			elseif minetest.get_item_group(node.name,"energy_producer")==1 then
				producers[#(producers)+1]=pos1
				if energy_find(pos1,conductors,producers,consumers,start_pos) then return true end
			elseif minetest.get_item_group(node.name,"energy_consumer")==1 then
				consumers[#(consumers)+1]=pos1
				if energy_find(pos1,conductors,producers,consumers,start_pos) then return true end
			elseif minetest.get_item_group(node.name,"energy")==1 then
				if pos1.x>start_pos.x then return true end
				if pos1.x==start_pos.x then
					if pos1.y>start_pos.y then return true end
					if pos1.y==start_pos.y then
						if pos1.z>start_pos.z then return true end
					end
				end
			end
		end
	end
end

--[[minetest.register_abm({
	nodenames = {"energy:battery"},
	interval = 1.0,
	chance = 1,
	action = function(pos, node, active_object_count, active_object_count_wider)
		found_nodes=energy_find_nodes(pos)
		local production=0
		local consumption=0
		for _,pos2 in ipairs(found_nodes.producers) do
			local meta=minetest.env:get_meta(pos2)
			production=production+meta:get_int("energy_production")
		end
		for _,pos2 in ipairs(found_nodes.consumers) do
			local meta=minetest.env:get_meta(pos2)
			consumption=consumption+meta:get_int("energy_use")
		end
		local cmeta=minetest.env:get_meta(pos)
		local energy=cmeta:get_int("energy")
		if production+energy>=consumption then
			cmeta:set_int("energy",production+energy-consumption)
			cmeta:set_string("infotext","Battery:"..tostring(production+energy-consumption))
			for _,pos in ipairs(found_nodes.consumers) do
				local meta=minetest.env:get_meta(pos)
				meta:set_int("active",1)
			end
		else
			cmeta:set_int("energy",production+energy)
			cmeta:set_string("infotext","Battery:"..tostring(production+energy))
			for _,pos in ipairs(found_nodes.consumers) do
				local meta=minetest.env:get_meta(pos)
				meta:set_int("active",0)
			end
		end
	end})]]

function get_connections()
	
end

minetest.register_globalstep(function(dtime)
	local con=get_connections()
end)